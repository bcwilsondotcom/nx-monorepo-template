#!/usr/bin/env node

import { Command } from 'commander';
import SwaggerParser from '@apidevtools/swagger-parser';
import { promises as fs } from 'fs';
import * as path from 'path';
import { format } from 'prettier';

interface GeneratorOptions {
  models?: boolean;
  client?: boolean;
  server?: boolean;
  validation?: boolean;
  output?: string;
  package?: string;
}

interface EndpointInfo {
  path: string;
  method: string;
  operationId: string;
  summary?: string;
  description?: string;
  parameters: ParameterInfo[];
  requestBody?: any;
  responses: ResponseInfo[];
  tags: string[];
  security?: any[];
}

interface ParameterInfo {
  name: string;
  in: 'query' | 'path' | 'header' | 'cookie';
  required: boolean;
  schema: any;
  description?: string;
}

interface ResponseInfo {
  statusCode: string;
  description: string;
  schema?: any;
  headers?: any;
}

interface ModelInfo {
  name: string;
  schema: any;
  description?: string;
}

class OpenAPIPythonGenerator {
  private spec: any = null;
  private endpoints: EndpointInfo[] = [];
  private models: ModelInfo[] = [];

  constructor(
    private specPath: string,
    private options: GeneratorOptions
  ) {}

  async generate(): Promise<void> {
    console.log(`Generating Python code from OpenAPI spec: ${this.specPath}`);

    await this.loadSpec();
    await this.parseEndpoints();
    await this.parseModels();
    await this.setupOutputDirectory();

    if (this.options.models) await this.generateModels();
    if (this.options.client) await this.generateClient();
    if (this.options.server) await this.generateServer();
    if (this.options.validation) await this.generateValidation();

    await this.generateInit();
    await this.generateRequirements();

    console.log('‚úÖ OpenAPI Python generation completed successfully!');
  }

  private async loadSpec(): Promise<void> {
    try {
      this.spec = await SwaggerParser.dereference(this.specPath);
      console.log(`üìã Loaded OpenAPI spec: ${this.spec.info.title} v${this.spec.info.version}`);
    } catch (error) {
      console.error('‚ùå Failed to load OpenAPI specification:', error);
      process.exit(1);
    }
  }

  private async parseEndpoints(): Promise<void> {
    if (!this.spec.paths) return;

    for (const [path, pathItem] of Object.entries(this.spec.paths)) {
      for (const [method, operation] of Object.entries(pathItem as any)) {
        if (!['get', 'post', 'put', 'patch', 'delete', 'head', 'options'].includes(method)) {
          continue;
        }

        const endpoint: EndpointInfo = {
          path,
          method: method.toUpperCase(),
          operationId: operation.operationId || this.generateOperationId(method, path),
          summary: operation.summary,
          description: operation.description,
          parameters: this.parseParameters(operation.parameters || []),
          requestBody: operation.requestBody,
          responses: this.parseResponses(operation.responses || {}),
          tags: operation.tags || [],
          security: operation.security,
        };

        this.endpoints.push(endpoint);
      }
    }

    console.log(`üìÑ Parsed ${this.endpoints.length} endpoints`);
  }

  private parseParameters(parameters: any[]): ParameterInfo[] {
    return parameters.map(param => ({
      name: param.name,
      in: param.in,
      required: param.required || false,
      schema: param.schema,
      description: param.description,
    }));
  }

  private parseResponses(responses: any): ResponseInfo[] {
    return Object.entries(responses).map(([statusCode, response]: [string, any]) => ({
      statusCode,
      description: response.description,
      schema: response.content?.['application/json']?.schema,
      headers: response.headers,
    }));
  }

  private async parseModels(): Promise<void> {
    if (!this.spec.components?.schemas) return;

    for (const [name, schema] of Object.entries(this.spec.components.schemas)) {
      this.models.push({
        name,
        schema: schema as any,
        description: (schema as any).description,
      });
    }

    console.log(`üì¶ Parsed ${this.models.length} models`);
  }

  private generateOperationId(method: string, path: string): string {
    return `${method.toLowerCase()}_${path.replace(/[^a-zA-Z0-9]/g, '_')}`;
  }

  private async setupOutputDirectory(): Promise<void> {
    const outputDir = this.options.output || 'generated';
    await fs.mkdir(outputDir, { recursive: true });
    console.log(`üìÅ Output directory: ${path.resolve(outputDir)}`);
  }

  private async generateModels(): Promise<void> {
    const outputPath = path.join(this.options.output || 'generated', 'models.py');

    let content = `"""Generated OpenAPI Python models\n`;
    content += `Do not edit this file directly\n`;
    content += `Generated from: ${path.basename(this.specPath)}\n"""\n\n`;

    content += `from __future__ import annotations\n`;
    content += `from datetime import datetime\n`;
    content += `from decimal import Decimal\n`;
    content += `from enum import Enum\n`;
    content += `from typing import Any, Dict, List, Optional, Union\n`;
    content += `from uuid import UUID\n\n`;
    content += `from pydantic import BaseModel, Field, validator\n\n`;

    // Generate enum classes first
    for (const model of this.models) {
      if (model.schema.enum) {
        content += this.generateEnumClass(model);
      }
    }

    // Generate model classes
    for (const model of this.models) {
      if (!model.schema.enum) {
        content += this.generateModelClass(model);
      }
    }

    await fs.writeFile(outputPath, content);
    console.log(`üìù Generated models: ${outputPath}`);
  }

  private generateEnumClass(model: ModelInfo): string {
    let content = `\nclass ${model.name}(str, Enum):\n`;

    if (model.description) {
      content += `    """${model.description}"""\n`;
    }

    for (const value of model.schema.enum) {
      const enumName = value.toUpperCase().replace(/[^A-Z0-9]/g, '_');
      content += `    ${enumName} = "${value}"\n`;
    }

    content += `\n`;
    return content;
  }

  private generateModelClass(model: ModelInfo): string {
    let content = `\nclass ${model.name}(BaseModel):\n`;

    if (model.description) {
      content += `    """${model.description}"""\n`;
    }

    if (!model.schema.properties) {
      content += `    pass\n\n`;
      return content;
    }

    // Generate field definitions
    for (const [propName, propSchema] of Object.entries(model.schema.properties)) {
      const prop = propSchema as any;
      const required = model.schema.required?.includes(propName) || false;
      const pythonType = this.getPythonType(prop, !required);

      content += `    ${propName}: ${pythonType}`;

      // Add Field for validation and metadata
      const fieldParams: string[] = [];

      if (prop.description) {
        fieldParams.push(`description="${prop.description}"`);
      }

      if (prop.example !== undefined) {
        fieldParams.push(`example=${JSON.stringify(prop.example)}`);
      }

      if (prop.minimum !== undefined) {
        fieldParams.push(`ge=${prop.minimum}`);
      }

      if (prop.maximum !== undefined) {
        fieldParams.push(`le=${prop.maximum}`);
      }

      if (prop.minLength !== undefined) {
        fieldParams.push(`min_length=${prop.minLength}`);
      }

      if (prop.maxLength !== undefined) {
        fieldParams.push(`max_length=${prop.maxLength}`);
      }

      if (prop.pattern) {
        fieldParams.push(`regex="${prop.pattern}"`);
      }

      if (!required) {
        fieldParams.unshift(`default=None`);
      }

      if (fieldParams.length > 0) {
        content += ` = Field(${fieldParams.join(', ')})`;
      }

      content += `\n`;
    }

    // Generate validators if needed
    content += this.generateValidators(model);

    content += `\n    class Config:\n`;
    content += `        use_enum_values = True\n`;
    content += `        validate_assignment = True\n`;
    content += `        extra = "forbid"\n\n`;

    return content;
  }

  private generateValidators(model: ModelInfo): string {
    let content = '';

    for (const [propName, propSchema] of Object.entries(model.schema.properties || {})) {
      const prop = propSchema as any;

      // Generate email validator
      if (prop.format === 'email') {
        content += `\n    @validator('${propName}')\n`;
        content += `    def validate_${propName}(cls, v):\n`;
        content += `        if v and '@' not in v:\n`;
        content += `            raise ValueError('Invalid email format')\n`;
        content += `        return v\n`;
      }

      // Generate URL validator
      if (prop.format === 'uri') {
        content += `\n    @validator('${propName}')\n`;
        content += `    def validate_${propName}(cls, v):\n`;
        content += `        if v and not v.startswith(('http://', 'https://')):\n`;
        content += `            raise ValueError('Invalid URL format')\n`;
        content += `        return v\n`;
      }
    }

    return content;
  }

  private getPythonType(schema: any, optional: boolean = false): string {
    let baseType = this.getBasePythonType(schema);

    if (optional && !baseType.startsWith('Optional[')) {
      baseType = `Optional[${baseType}]`;
    }

    return baseType;
  }

  private getBasePythonType(schema: any): string {
    if (schema.$ref) {
      const refName = schema.$ref.split('/').pop();
      return refName;
    }

    switch (schema.type) {
      case 'string':
        if (schema.enum) {
          // Assume enum class exists
          return 'str';  // Will be replaced with actual enum class name
        }
        if (schema.format === 'date-time') return 'datetime';
        if (schema.format === 'date') return 'datetime';
        if (schema.format === 'uuid') return 'UUID';
        if (schema.format === 'email') return 'str';
        if (schema.format === 'uri') return 'str';
        return 'str';

      case 'number':
        if (schema.format === 'float') return 'float';
        if (schema.format === 'double') return 'float';
        return 'Decimal';

      case 'integer':
        if (schema.format === 'int64') return 'int';
        return 'int';

      case 'boolean':
        return 'bool';

      case 'array':
        const itemType = this.getBasePythonType(schema.items);
        return `List[${itemType}]`;

      case 'object':
        if (schema.additionalProperties) {
          const valueType = this.getBasePythonType(schema.additionalProperties);
          return `Dict[str, ${valueType}]`;
        }
        return 'Dict[str, Any]';

      default:
        return 'Any';
    }
  }

  private async generateClient(): Promise<void> {
    const outputPath = path.join(this.options.output || 'generated', 'client.py');

    let content = `"""Generated OpenAPI Python client\n`;
    content += `Do not edit this file directly\n`;
    content += `Generated from: ${path.basename(this.specPath)}\n"""\n\n`;

    content += `import json\n`;
    content += `from typing import Any, Dict, List, Optional, Union\n`;
    content += `from urllib.parse import urljoin\n\n`;
    content += `import httpx\n`;
    content += `from pydantic import ValidationError\n\n`;
    content += `from .models import *\n\n`;

    // Generate API client class
    content += this.generateClientClass();

    // Generate endpoint methods
    content += this.generateClientMethods();

    await fs.writeFile(outputPath, content);
    console.log(`üìù Generated client: ${outputPath}`);
  }

  private generateClientClass(): string {
    return `
class APIClient:
    """Generated API client for ${this.spec.info.title}"""

    def __init__(
        self,
        base_url: str,
        api_key: Optional[str] = None,
        timeout: float = 30.0,
        verify_ssl: bool = True,
    ):
        self.base_url = base_url.rstrip('/')
        self.timeout = timeout

        headers = {
            'Content-Type': 'application/json',
            'Accept': 'application/json',
            'User-Agent': '${this.spec.info.title}-client/1.0.0',
        }

        if api_key:
            headers['Authorization'] = f'Bearer {api_key}'

        self.client = httpx.Client(
            headers=headers,
            timeout=timeout,
            verify=verify_ssl,
        )

    def __enter__(self):
        return self

    def __exit__(self, exc_type, exc_val, exc_tb):
        self.close()

    def close(self):
        """Close the HTTP client"""
        self.client.close()

    async def __aenter__(self):
        return self

    async def __aexit__(self, exc_type, exc_val, exc_tb):
        await self.aclose()

    async def aclose(self):
        """Close the async HTTP client"""
        if hasattr(self.client, 'aclose'):
            await self.client.aclose()

    def _make_request(
        self,
        method: str,
        path: str,
        params: Optional[Dict[str, Any]] = None,
        json_data: Optional[Dict[str, Any]] = None,
        headers: Optional[Dict[str, str]] = None,
    ) -> httpx.Response:
        """Make HTTP request"""
        url = urljoin(self.base_url + '/', path.lstrip('/'))

        try:
            response = self.client.request(
                method=method,
                url=url,
                params=params,
                json=json_data,
                headers=headers,
            )
            response.raise_for_status()
            return response
        except httpx.HTTPStatusError as e:
            self._handle_http_error(e)
        except httpx.RequestError as e:
            raise APIException(f"Request failed: {e}")

    def _handle_http_error(self, error: httpx.HTTPStatusError):
        """Handle HTTP errors with proper exception types"""
        status_code = error.response.status_code

        try:
            error_data = error.response.json()
        except (json.JSONDecodeError, ValueError):
            error_data = {"message": error.response.text}

        if status_code == 400:
            raise BadRequestError(error_data.get("message", "Bad request"))
        elif status_code == 401:
            raise UnauthorizedError(error_data.get("message", "Unauthorized"))
        elif status_code == 403:
            raise ForbiddenError(error_data.get("message", "Forbidden"))
        elif status_code == 404:
            raise NotFoundError(error_data.get("message", "Not found"))
        elif status_code == 422:
            raise ValidationError(error_data.get("message", "Validation error"))
        elif status_code >= 500:
            raise ServerError(error_data.get("message", "Internal server error"))
        else:
            raise APIException(f"HTTP {status_code}: {error_data.get('message', 'Unknown error')}")

    def _parse_response(self, response: httpx.Response, model_class=None):
        """Parse response with optional model validation"""
        if response.status_code == 204:  # No Content
            return None

        try:
            data = response.json()
        except (json.JSONDecodeError, ValueError):
            return response.text

        if model_class:
            try:
                return model_class.parse_obj(data)
            except ValidationError as e:
                raise APIException(f"Response validation failed: {e}")

        return data
`;
  }

  private generateClientMethods(): string {
    let content = '\n';

    // Group endpoints by tags
    const endpointsByTag = new Map<string, EndpointInfo[]>();
    for (const endpoint of this.endpoints) {
      const tag = endpoint.tags[0] || 'default';
      if (!endpointsByTag.has(tag)) {
        endpointsByTag.set(tag, []);
      }
      endpointsByTag.get(tag)!.push(endpoint);
    }

    // Generate methods for each endpoint
    for (const endpoint of this.endpoints) {
      content += this.generateClientMethod(endpoint);
    }

    // Generate exception classes
    content += this.generateExceptionClasses();

    return content;
  }

  private generateClientMethod(endpoint: EndpointInfo): string {
    const methodName = this.pythonMethodName(endpoint.operationId);
    const pathParams = endpoint.parameters.filter(p => p.in === 'path');
    const queryParams = endpoint.parameters.filter(p => p.in === 'query');
    const headerParams = endpoint.parameters.filter(p => p.in === 'header');

    let content = `\n    def ${methodName}(\n        self,\n`;

    // Add path parameters
    for (const param of pathParams) {
      const paramType = this.getPythonType(param.schema, !param.required);
      content += `        ${param.name}: ${paramType},\n`;
    }

    // Add request body parameter
    if (endpoint.requestBody) {
      const bodySchema = endpoint.requestBody.content?.['application/json']?.schema;
      if (bodySchema) {
        const bodyType = this.getPythonType(bodySchema, false);
        content += `        body: ${bodyType},\n`;
      }
    }

    // Add query parameters
    if (queryParams.length > 0) {
      content += `        # Query parameters\n`;
      for (const param of queryParams) {
        const paramType = this.getPythonType(param.schema, !param.required);
        content += `        ${param.name}: ${paramType} = None,\n`;
      }
    }

    // Add header parameters
    if (headerParams.length > 0) {
      content += `        # Header parameters\n`;
      for (const param of headerParams) {
        const paramType = this.getPythonType(param.schema, !param.required);
        content += `        ${param.name}: ${paramType} = None,\n`;
      }
    }

    content += `    ):\n`;

    // Add docstring
    content += `        """\n`;
    if (endpoint.summary) {
      content += `        ${endpoint.summary}\n\n`;
    }
    if (endpoint.description) {
      content += `        ${endpoint.description}\n\n`;
    }

    content += `        Args:\n`;
    for (const param of pathParams) {
      content += `            ${param.name}: ${param.description || 'Path parameter'}\n`;
    }
    if (endpoint.requestBody) {
      content += `            body: Request body\n`;
    }
    for (const param of [...queryParams, ...headerParams]) {
      content += `            ${param.name}: ${param.description || 'Parameter'}\n`;
    }

    content += `        """\n`;

    // Build path with parameters
    let pathBuilder = `"${endpoint.path}"`;
    for (const param of pathParams) {
      pathBuilder = pathBuilder.replace(`{${param.name}}`, `{${param.name}}`);
    }
    content += `        path = f${pathBuilder}\n`;

    // Build query parameters
    if (queryParams.length > 0) {
      content += `        params = {}\n`;
      for (const param of queryParams) {
        content += `        if ${param.name} is not None:\n`;
        content += `            params["${param.name}"] = ${param.name}\n`;
      }
    }

    // Build headers
    if (headerParams.length > 0) {
      content += `        headers = {}\n`;
      for (const param of headerParams) {
        content += `        if ${param.name} is not None:\n`;
        content += `            headers["${param.name}"] = ${param.name}\n`;
      }
    }

    // Make request
    content += `        response = self._make_request(\n`;
    content += `            method="${endpoint.method}",\n`;
    content += `            path=path,\n`;
    if (queryParams.length > 0) {
      content += `            params=params,\n`;
    }
    if (endpoint.requestBody) {
      content += `            json_data=body.dict() if hasattr(body, 'dict') else body,\n`;
    }
    if (headerParams.length > 0) {
      content += `            headers=headers,\n`;
    }
    content += `        )\n`;

    // Parse response
    const successResponse = endpoint.responses.find(r => r.statusCode.startsWith('2'));
    if (successResponse?.schema) {
      const responseType = this.getPythonType(successResponse.schema);
      content += `        return self._parse_response(response, ${responseType})\n`;
    } else {
      content += `        return self._parse_response(response)\n`;
    }

    return content;
  }

  private generateExceptionClasses(): string {
    return `

# Exception classes
class APIException(Exception):
    """Base API exception"""
    pass

class BadRequestError(APIException):
    """400 Bad Request"""
    pass

class UnauthorizedError(APIException):
    """401 Unauthorized"""
    pass

class ForbiddenError(APIException):
    """403 Forbidden"""
    pass

class NotFoundError(APIException):
    """404 Not Found"""
    pass

class ValidationError(APIException):
    """422 Validation Error"""
    pass

class ServerError(APIException):
    """5xx Server Error"""
    pass
`;
  }

  private pythonMethodName(operationId: string): string {
    return operationId
      .replace(/[^a-zA-Z0-9]/g, '_')
      .toLowerCase()
      .replace(/_{2,}/g, '_')
      .replace(/^_|_$/g, '');
  }

  private async generateServer(): Promise<void> {
    const outputPath = path.join(this.options.output || 'generated', 'server.py');

    let content = `"""Generated OpenAPI Python server (FastAPI)\n`;
    content += `Do not edit this file directly\n`;
    content += `Generated from: ${path.basename(this.specPath)}\n"""\n\n`;

    content += `from fastapi import FastAPI, HTTPException, Depends, status\n`;
    content += `from fastapi.responses import JSONResponse\n`;
    content += `from fastapi.security import HTTPBearer, HTTPAuthorizationCredentials\n`;
    content += `from typing import Any, Dict, List, Optional\n\n`;
    content += `from .models import *\n\n`;

    // Generate FastAPI app
    content += this.generateFastAPIApp();

    // Generate route handlers
    content += this.generateRouteHandlers();

    await fs.writeFile(outputPath, content);
    console.log(`üìù Generated server: ${outputPath}`);
  }

  private generateFastAPIApp(): string {
    return `
# FastAPI application
app = FastAPI(
    title="${this.spec.info.title}",
    description="${this.spec.info.description || ''}",
    version="${this.spec.info.version}",
    docs_url="/docs",
    redoc_url="/redoc",
    openapi_url="/openapi.json",
)

# Security
security = HTTPBearer()

async def get_current_user(credentials: HTTPAuthorizationCredentials = Depends(security)):
    """
    Validate JWT token and return current user
    Override this function with your authentication logic
    """
    # TODO: Implement authentication logic
    return {"user_id": "example"}

# Error handlers
@app.exception_handler(ValidationError)
async def validation_exception_handler(request, exc):
    return JSONResponse(
        status_code=422,
        content={"message": "Validation error", "details": str(exc)}
    )

@app.exception_handler(HTTPException)
async def http_exception_handler(request, exc):
    return JSONResponse(
        status_code=exc.status_code,
        content={"message": exc.detail}
    )
`;
  }

  private generateRouteHandlers(): string {
    let content = '\n# Route handlers\n';

    for (const endpoint of this.endpoints) {
      content += this.generateRouteHandler(endpoint);
    }

    return content;
  }

  private generateRouteHandler(endpoint: EndpointInfo): string {
    const methodName = this.pythonMethodName(endpoint.operationId);
    const pathParams = endpoint.parameters.filter(p => p.in === 'path');
    const queryParams = endpoint.parameters.filter(p => p.in === 'query');

    let content = `\n@app.${endpoint.method.toLowerCase()}("${endpoint.path}"`;

    // Add response model
    const successResponse = endpoint.responses.find(r => r.statusCode.startsWith('2'));
    if (successResponse?.schema) {
      const responseType = this.getPythonType(successResponse.schema);
      content += `, response_model=${responseType}`;
    }

    // Add status code
    if (successResponse) {
      content += `, status_code=${successResponse.statusCode}`;
    }

    // Add tags
    if (endpoint.tags.length > 0) {
      content += `, tags=["${endpoint.tags[0]}"]`;
    }

    content += `)\n`;
    content += `async def ${methodName}(\n`;

    // Add path parameters
    for (const param of pathParams) {
      const paramType = this.getPythonType(param.schema, !param.required);
      content += `    ${param.name}: ${paramType},\n`;
    }

    // Add request body
    if (endpoint.requestBody) {
      const bodySchema = endpoint.requestBody.content?.['application/json']?.schema;
      if (bodySchema) {
        const bodyType = this.getPythonType(bodySchema);
        content += `    body: ${bodyType},\n`;
      }
    }

    // Add query parameters
    for (const param of queryParams) {
      const paramType = this.getPythonType(param.schema, !param.required);
      const defaultValue = param.required ? '' : ' = None';
      content += `    ${param.name}: ${paramType}${defaultValue},\n`;
    }

    // Add authentication dependency if needed
    if (endpoint.security && endpoint.security.length > 0) {
      content += `    current_user: dict = Depends(get_current_user),\n`;
    }

    content += `):\n`;

    // Add docstring
    content += `    """\n`;
    if (endpoint.summary) {
      content += `    ${endpoint.summary}\n\n`;
    }
    if (endpoint.description) {
      content += `    ${endpoint.description}\n`;
    }
    content += `    """\n`;

    // Add placeholder implementation
    content += `    # TODO: Implement ${methodName}\n`;
    content += `    raise HTTPException(\n`;
    content += `        status_code=501,\n`;
    content += `        detail="Not implemented"\n`;
    content += `    )\n`;

    return content;
  }

  private async generateValidation(): Promise<void> {
    const outputPath = path.join(this.options.output || 'generated', 'validation.py');

    let content = `"""Generated OpenAPI Python validation utilities\n`;
    content += `Do not edit this file directly\n`;
    content += `Generated from: ${path.basename(this.specPath)}\n"""\n\n`;

    content += `from typing import Any, Dict, List, Optional, Type, TypeVar\n`;
    content += `from pydantic import BaseModel, ValidationError\n\n`;
    content += `from .models import *\n\n`;

    content += `T = TypeVar('T', bound=BaseModel)\n\n`;

    // Generate validation utilities
    content += this.generateValidationUtilities();

    await fs.writeFile(outputPath, content);
    console.log(`üìù Generated validation: ${outputPath}`);
  }

  private generateValidationUtilities(): string {
    return `
class ValidationUtils:
    """Utility functions for model validation"""

    @staticmethod
    def validate_model(model_class: Type[T], data: Dict[str, Any]) -> T:
        """
        Validate data against a Pydantic model

        Args:
            model_class: The Pydantic model class
            data: Data to validate

        Returns:
            Validated model instance

        Raises:
            ValidationError: If validation fails
        """
        return model_class.parse_obj(data)

    @staticmethod
    def safe_validate_model(model_class: Type[T], data: Dict[str, Any]) -> Optional[T]:
        """
        Safely validate data against a Pydantic model

        Args:
            model_class: The Pydantic model class
            data: Data to validate

        Returns:
            Validated model instance or None if validation fails
        """
        try:
            return model_class.parse_obj(data)
        except ValidationError:
            return None

    @staticmethod
    def get_validation_errors(model_class: Type[BaseModel], data: Dict[str, Any]) -> List[str]:
        """
        Get validation error messages for data

        Args:
            model_class: The Pydantic model class
            data: Data to validate

        Returns:
            List of validation error messages
        """
        try:
            model_class.parse_obj(data)
            return []
        except ValidationError as e:
            return [f"{'.'.join(str(loc) for loc in error['loc'])}: {error['msg']}" for error in e.errors()]

    @staticmethod
    def validate_json_string(model_class: Type[T], json_str: str) -> T:
        """
        Validate JSON string against a Pydantic model

        Args:
            model_class: The Pydantic model class
            json_str: JSON string to validate

        Returns:
            Validated model instance

        Raises:
            ValidationError: If validation fails
        """
        return model_class.parse_raw(json_str)

    @staticmethod
    def model_to_dict(model: BaseModel, exclude_none: bool = True) -> Dict[str, Any]:
        """
        Convert Pydantic model to dictionary

        Args:
            model: Pydantic model instance
            exclude_none: Whether to exclude None values

        Returns:
            Dictionary representation of the model
        """
        return model.dict(exclude_none=exclude_none)

    @staticmethod
    def models_to_dict_list(models: List[BaseModel], exclude_none: bool = True) -> List[Dict[str, Any]]:
        """
        Convert list of Pydantic models to list of dictionaries

        Args:
            models: List of Pydantic model instances
            exclude_none: Whether to exclude None values

        Returns:
            List of dictionary representations
        """
        return [model.dict(exclude_none=exclude_none) for model in models]

# Model-specific validation functions
${this.models.map(model => `
def validate_${model.name.toLowerCase()}(data: Dict[str, Any]) -> ${model.name}:
    """Validate data as ${model.name}"""
    return ValidationUtils.validate_model(${model.name}, data)

def safe_validate_${model.name.toLowerCase()}(data: Dict[str, Any]) -> Optional[${model.name}]:
    """Safely validate data as ${model.name}"""
    return ValidationUtils.safe_validate_model(${model.name}, data)
`).join('')}
`;
  }

  private async generateInit(): Promise<void> {
    const outputPath = path.join(this.options.output || 'generated', '__init__.py');

    let content = `"""Generated OpenAPI Python package\n`;
    content += `Do not edit this file directly\n`;
    content += `Generated from: ${path.basename(this.specPath)}\n"""\n\n`;

    content += `__version__ = "1.0.0"\n\n`;

    if (this.options.models) {
      content += `from .models import *\n`;
    }

    if (this.options.client) {
      content += `from .client import APIClient\n`;
    }

    if (this.options.server) {
      content += `from .server import app\n`;
    }

    if (this.options.validation) {
      content += `from .validation import ValidationUtils\n`;
    }

    content += `\n__all__ = [\n`;

    if (this.options.client) {
      content += `    "APIClient",\n`;
    }

    if (this.options.server) {
      content += `    "app",\n`;
    }

    if (this.options.validation) {
      content += `    "ValidationUtils",\n`;
    }

    // Add model exports
    for (const model of this.models) {
      content += `    "${model.name}",\n`;
    }

    content += `]\n`;

    await fs.writeFile(outputPath, content);
    console.log(`üìù Generated __init__.py: ${outputPath}`);
  }

  private async generateRequirements(): Promise<void> {
    const outputPath = path.join(this.options.output || 'generated', 'requirements.txt');

    let content = `# Generated OpenAPI Python requirements\n`;
    content += `# Do not edit this file directly\n`;
    content += `# Generated from: ${path.basename(this.specPath)}\n\n`;

    content += `# Core dependencies\n`;
    content += `pydantic>=1.10.0\n`;
    content += `httpx>=0.24.0\n\n`;

    if (this.options.server) {
      content += `# Server dependencies\n`;
      content += `fastapi>=0.100.0\n`;
      content += `uvicorn>=0.22.0\n\n`;
    }

    if (this.options.validation) {
      content += `# Validation dependencies\n`;
      content += `email-validator>=2.0.0\n\n`;
    }

    await fs.writeFile(outputPath, content);
    console.log(`üìù Generated requirements.txt: ${outputPath}`);
  }
}

// CLI Program
const program = new Command();

program
  .name('gen-openapi-python')
  .description('Generate Python code from OpenAPI specifications')
  .version('1.0.0');

program
  .argument('<spec>', 'Path to OpenAPI specification file')
  .option('-o, --output <dir>', 'Output directory', 'generated')
  .option('-p, --package <name>', 'Python package name')
  .option('--models', 'Generate Pydantic models', true)
  .option('--client', 'Generate HTTP client', true)
  .option('--server', 'Generate FastAPI server stubs', true)
  .option('--validation', 'Generate validation utilities', true)
  .option('--no-models', 'Skip model generation')
  .option('--no-client', 'Skip client generation')
  .option('--no-server', 'Skip server generation')
  .option('--no-validation', 'Skip validation generation')
  .action(async (specPath: string, options: GeneratorOptions) => {
    try {
      const generator = new OpenAPIPythonGenerator(specPath, options);
      await generator.generate();
    } catch (error) {
      console.error('‚ùå Generation failed:', error);
      process.exit(1);
    }
  });

// Example usage command
program
  .command('example')
  .description('Show example usage')
  .action(() => {
    console.log(`
üìñ OpenAPI Python Generator Examples:

# Generate all code from OpenAPI spec
gen-openapi-python api.yaml

# Generate to specific directory with package name
gen-openapi-python api.yaml -o src/api_client -p my_api

# Generate only models and client
gen-openapi-python api.yaml --no-server --no-validation

# Generate only server stubs
gen-openapi-python api.yaml --no-models --no-client --no-validation

Generated files:
- models.py         - Pydantic models
- client.py         - HTTP client with httpx
- server.py         - FastAPI server stubs
- validation.py     - Validation utilities
- __init__.py       - Package initialization
- requirements.txt  - Python dependencies

Usage in your code:
\`\`\`python
from generated import APIClient, User, ValidationUtils

# Use the client
async with APIClient("https://api.example.com") as client:
    user = await client.get_user(user_id="123")
    print(f"User: {user.name}")

# Validate data
data = {"name": "John", "email": "john@example.com"}
user = ValidationUtils.validate_model(User, data)

# Use FastAPI server
from generated.server import app
# Run with: uvicorn generated.server:app --reload
\`\`\`
    `);
  });

if (require.main === module) {
  program.parse();
}

export { OpenAPIPythonGenerator };
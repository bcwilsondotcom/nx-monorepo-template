#!/usr/bin/env node

import { Command } from 'commander';
import { AsyncAPIDocument, Parser } from '@asyncapi/parser';
import { promises as fs } from 'fs';
import * as path from 'path';
import { format } from 'prettier';

interface GeneratorOptions {
  types?: boolean;
  client?: boolean;
  handlers?: boolean;
  validation?: boolean;
  output?: string;
  namespace?: string;
}

interface ChannelInfo {
  name: string;
  address: string;
  description?: string;
  subscribe?: MessageInfo[];
  publish?: MessageInfo[];
}

interface MessageInfo {
  name: string;
  title?: string;
  description?: string;
  payload: any;
  headers?: any;
  contentType?: string;
}

class AsyncAPITypeScriptGenerator {
  private spec: AsyncAPIDocument | null = null;
  private channels: ChannelInfo[] = [];
  private messages: Map<string, MessageInfo> = new Map();

  constructor(
    private specPath: string,
    private options: GeneratorOptions
  ) {}

  async generate(): Promise<void> {
    console.log(`Generating TypeScript code from AsyncAPI spec: ${this.specPath}`);

    await this.loadSpec();
    await this.parseChannelsAndMessages();
    await this.setupOutputDirectory();

    if (this.options.types) await this.generateTypes();
    if (this.options.client) await this.generateClient();
    if (this.options.handlers) await this.generateHandlers();
    if (this.options.validation) await this.generateValidation();

    console.log('‚úÖ AsyncAPI TypeScript generation completed successfully!');
  }

  private async loadSpec(): Promise<void> {
    try {
      const content = await fs.readFile(this.specPath, 'utf-8');
      const parser = new Parser();
      const { document, diagnostics } = await parser.parse(content);

      if (diagnostics.length > 0) {
        console.warn('AsyncAPI parsing warnings:');
        diagnostics.forEach(diag => console.warn(`  - ${diag.message}`));
      }

      this.spec = document;
      console.log(`üìã Loaded AsyncAPI spec: ${this.spec?.info().title()} v${this.spec?.info().version()}`);
    } catch (error) {
      console.error('‚ùå Failed to load AsyncAPI specification:', error);
      process.exit(1);
    }
  }

  private async parseChannelsAndMessages(): Promise<void> {
    if (!this.spec) return;

    // Parse channels
    const channels = this.spec.channels();
    for (const [address, channel] of channels) {
      const channelInfo: ChannelInfo = {
        name: this.sanitizeName(address),
        address,
        description: channel.description(),
        subscribe: [],
        publish: []
      };

      // Parse subscribe operations (messages we receive)
      const subscribeOp = channel.subscribe();
      if (subscribeOp) {
        for (const message of subscribeOp.messages()) {
          const messageInfo = this.parseMessage(message);
          channelInfo.subscribe.push(messageInfo);
          this.messages.set(messageInfo.name, messageInfo);
        }
      }

      // Parse publish operations (messages we send)
      const publishOp = channel.publish();
      if (publishOp) {
        for (const message of publishOp.messages()) {
          const messageInfo = this.parseMessage(message);
          channelInfo.publish.push(messageInfo);
          this.messages.set(messageInfo.name, messageInfo);
        }
      }

      this.channels.push(channelInfo);
    }

    console.log(`üìÑ Parsed ${this.channels.length} channels and ${this.messages.size} message types`);
  }

  private parseMessage(message: any): MessageInfo {
    const name = this.sanitizeName(message.id() || message.name() || 'UnknownMessage');
    return {
      name,
      title: message.title(),
      description: message.description(),
      payload: message.payload(),
      headers: message.headers(),
      contentType: message.contentType()
    };
  }

  private sanitizeName(name: string): string {
    return name
      .replace(/[^a-zA-Z0-9]/g, '_')
      .replace(/^[0-9]/, '_$&')
      .replace(/_{2,}/g, '_')
      .replace(/^_|_$/g, '');
  }

  private async setupOutputDirectory(): Promise<void> {
    const outputDir = this.options.output || 'generated';
    await fs.mkdir(outputDir, { recursive: true });
    console.log(`üìÅ Output directory: ${path.resolve(outputDir)}`);
  }

  private async generateTypes(): Promise<void> {
    const outputPath = path.join(this.options.output || 'generated', 'types.ts');

    let content = `// Generated AsyncAPI TypeScript types\n`;
    content += `// Do not edit this file directly\n`;
    content += `// Generated from: ${path.basename(this.specPath)}\n\n`;

    if (this.options.namespace) {
      content += `export namespace ${this.options.namespace} {\n`;
    }

    // Generate message payload types
    content += `// Message Payload Types\n`;
    for (const [name, message] of this.messages) {
      content += this.generateMessageType(message);
    }

    // Generate channel types
    content += `\n// Channel Types\n`;
    content += this.generateChannelTypes();

    // Generate event emitter types
    content += `\n// Event Types\n`;
    content += this.generateEventTypes();

    if (this.options.namespace) {
      content += `}\n`;
    }

    const formatted = await this.formatCode(content);
    await fs.writeFile(outputPath, formatted);
    console.log(`üìù Generated types: ${outputPath}`);
  }

  private generateMessageType(message: MessageInfo): string {
    let content = ``;

    if (message.description) {
      content += `/**\n * ${message.description}\n */\n`;
    }

    content += `export interface ${message.name}Payload {\n`;
    content += this.generateInterfaceProperties(message.payload);
    content += `}\n\n`;

    if (message.headers) {
      content += `export interface ${message.name}Headers {\n`;
      content += this.generateInterfaceProperties(message.headers);
      content += `}\n\n`;
    }

    content += `export interface ${message.name}Message {\n`;
    content += `  payload: ${message.name}Payload;\n`;
    if (message.headers) {
      content += `  headers?: ${message.name}Headers;\n`;
    }
    content += `  timestamp?: string;\n`;
    content += `  messageId?: string;\n`;
    content += `}\n\n`;

    return content;
  }

  private generateInterfaceProperties(schema: any): string {
    if (!schema || !schema.properties) {
      return `  [key: string]: any;\n`;
    }

    let content = '';
    for (const [propName, propSchema] of Object.entries(schema.properties)) {
      const prop = propSchema as any;
      const optional = !schema.required?.includes(propName) ? '?' : '';
      const type = this.getTypeScriptType(prop);

      if (prop.description) {
        content += `  /** ${prop.description} */\n`;
      }
      content += `  ${propName}${optional}: ${type};\n`;
    }

    return content;
  }

  private getTypeScriptType(schema: any): string {
    if (!schema) return 'any';

    switch (schema.type) {
      case 'string':
        if (schema.enum) {
          return schema.enum.map((v: string) => `'${v}'`).join(' | ');
        }
        return 'string';
      case 'number':
      case 'integer':
        return 'number';
      case 'boolean':
        return 'boolean';
      case 'array':
        const itemType = this.getTypeScriptType(schema.items);
        return `${itemType}[]`;
      case 'object':
        if (schema.properties) {
          let objType = '{\n';
          for (const [propName, propSchema] of Object.entries(schema.properties)) {
            const prop = propSchema as any;
            const optional = !schema.required?.includes(propName) ? '?' : '';
            const type = this.getTypeScriptType(prop);
            objType += `    ${propName}${optional}: ${type};\n`;
          }
          objType += '  }';
          return objType;
        }
        return 'Record<string, any>';
      default:
        return 'any';
    }
  }

  private generateChannelTypes(): string {
    let content = `export interface ChannelMap {\n`;

    for (const channel of this.channels) {
      content += `  '${channel.address}': {\n`;

      if (channel.subscribe.length > 0) {
        content += `    subscribe: `;
        const subscribeTypes = channel.subscribe.map(msg => `${msg.name}Message`);
        content += subscribeTypes.length === 1 ? subscribeTypes[0] : `(${subscribeTypes.join(' | ')})`;
        content += `;\n`;
      }

      if (channel.publish.length > 0) {
        content += `    publish: `;
        const publishTypes = channel.publish.map(msg => `${msg.name}Message`);
        content += publishTypes.length === 1 ? publishTypes[0] : `(${publishTypes.join(' | ')})`;
        content += `;\n`;
      }

      content += `  };\n`;
    }

    content += `}\n\n`;
    content += `export type ChannelName = keyof ChannelMap;\n`;

    return content;
  }

  private generateEventTypes(): string {
    const allMessages = Array.from(this.messages.values());

    let content = `export type AllMessages = \n`;
    content += allMessages.map(msg => `  | ${msg.name}Message`).join('\n');
    content += `;\n\n`;

    content += `export interface EventMap {\n`;
    for (const message of allMessages) {
      content += `  '${message.name}': ${message.name}Message;\n`;
    }
    content += `}\n\n`;

    content += `export type EventName = keyof EventMap;\n`;

    return content;
  }

  private async generateClient(): Promise<void> {
    const outputPath = path.join(this.options.output || 'generated', 'client.ts');

    let content = `// Generated AsyncAPI TypeScript client\n`;
    content += `// Do not edit this file directly\n`;
    content += `// Generated from: ${path.basename(this.specPath)}\n\n`;

    content += `import { EventEmitter } from 'events';\n`;
    if (this.options.namespace) {
      content += `import { ${this.options.namespace} } from './types';\n\n`;
      content += `type EventMap = ${this.options.namespace}.EventMap;\n`;
      content += `type ChannelMap = ${this.options.namespace}.ChannelMap;\n`;
      content += `type ChannelName = ${this.options.namespace}.ChannelName;\n`;
      content += `type AllMessages = ${this.options.namespace}.AllMessages;\n`;
    } else {
      content += `import { EventMap, ChannelMap, ChannelName, AllMessages } from './types';\n`;
    }
    content += `\n`;

    // Generate WebSocket client
    content += this.generateWebSocketClient();

    // Generate event bus
    content += this.generateEventBus();

    // Generate channel-specific clients
    content += this.generateChannelClients();

    const formatted = await this.formatCode(content);
    await fs.writeFile(outputPath, formatted);
    console.log(`üìù Generated client: ${outputPath}`);
  }

  private generateWebSocketClient(): string {
    return `
export interface WebSocketClientOptions {
  url: string;
  protocols?: string[];
  reconnect?: boolean;
  reconnectInterval?: number;
  maxReconnectAttempts?: number;
}

export class AsyncAPIWebSocketClient extends EventEmitter {
  private ws: WebSocket | null = null;
  private reconnectAttempts = 0;
  private reconnectTimer: NodeJS.Timeout | null = null;

  constructor(private options: WebSocketClientOptions) {
    super();
  }

  async connect(): Promise<void> {
    return new Promise((resolve, reject) => {
      try {
        this.ws = new WebSocket(this.options.url, this.options.protocols);

        this.ws.onopen = () => {
          console.log('WebSocket connected');
          this.reconnectAttempts = 0;
          this.emit('connected');
          resolve();
        };

        this.ws.onmessage = (event) => {
          this.handleMessage(event.data);
        };

        this.ws.onclose = (event) => {
          console.log('WebSocket disconnected:', event.code, event.reason);
          this.emit('disconnected', event);

          if (this.options.reconnect && this.reconnectAttempts < (this.options.maxReconnectAttempts || 5)) {
            this.scheduleReconnect();
          }
        };

        this.ws.onerror = (error) => {
          console.error('WebSocket error:', error);
          this.emit('error', error);
          reject(error);
        };
      } catch (error) {
        reject(error);
      }
    });
  }

  disconnect(): void {
    if (this.reconnectTimer) {
      clearTimeout(this.reconnectTimer);
      this.reconnectTimer = null;
    }

    if (this.ws) {
      this.ws.close();
      this.ws = null;
    }
  }

  send<T extends keyof EventMap>(channel: string, message: EventMap[T]): void {
    if (!this.ws || this.ws.readyState !== WebSocket.OPEN) {
      throw new Error('WebSocket is not connected');
    }

    const envelope = {
      channel,
      ...message,
      timestamp: new Date().toISOString(),
      messageId: this.generateMessageId()
    };

    this.ws.send(JSON.stringify(envelope));
  }

  private handleMessage(data: string): void {
    try {
      const envelope = JSON.parse(data);
      const { channel, ...message } = envelope;

      this.emit('message', { channel, message });
      this.emit(\`channel:\${channel}\`, message);

      // Emit specific message type events
      if (message.payload && typeof message.payload === 'object') {
        const messageType = this.inferMessageType(message);
        if (messageType) {
          this.emit(messageType, message);
        }
      }
    } catch (error) {
      console.error('Failed to parse WebSocket message:', error);
      this.emit('error', error);
    }
  }

  private scheduleReconnect(): void {
    this.reconnectAttempts++;
    const delay = this.options.reconnectInterval || 5000;

    this.reconnectTimer = setTimeout(() => {
      console.log(\`Attempting to reconnect... (attempt \${this.reconnectAttempts})\`);
      this.connect().catch(() => {
        // Reconnection will be scheduled again if it fails
      });
    }, delay);
  }

  private generateMessageId(): string {
    return \`\${Date.now()}-\${Math.random().toString(36).substr(2, 9)}\`;
  }

  private inferMessageType(message: any): string | null {
    // Simple heuristic to infer message type from payload structure
    // In a real implementation, you might use a discriminator field
    return null;
  }
}
`;
  }

  private generateEventBus(): string {
    return `
export class AsyncAPIEventBus extends EventEmitter {
  private subscribers: Map<string, Set<Function>> = new Map();

  subscribe<T extends keyof EventMap>(
    eventName: T,
    handler: (message: EventMap[T]) => void | Promise<void>
  ): () => void {
    if (!this.subscribers.has(eventName as string)) {
      this.subscribers.set(eventName as string, new Set());
    }

    this.subscribers.get(eventName as string)!.add(handler);
    this.on(eventName as string, handler);

    return () => {
      this.subscribers.get(eventName as string)?.delete(handler);
      this.off(eventName as string, handler);
    };
  }

  publish<T extends keyof EventMap>(
    eventName: T,
    message: EventMap[T]
  ): void {
    this.emit(eventName as string, message);
  }

  async publishAsync<T extends keyof EventMap>(
    eventName: T,
    message: EventMap[T]
  ): Promise<void> {
    const handlers = this.subscribers.get(eventName as string) || new Set();

    const promises = Array.from(handlers).map(async (handler) => {
      try {
        await handler(message);
      } catch (error) {
        console.error(\`Error in event handler for \${String(eventName)}:\`, error);
        this.emit('error', error);
      }
    });

    await Promise.all(promises);
  }

  getSubscriberCount(eventName: keyof EventMap): number {
    return this.subscribers.get(eventName as string)?.size || 0;
  }

  clear(): void {
    this.removeAllListeners();
    this.subscribers.clear();
  }
}
`;
  }

  private generateChannelClients(): string {
    let content = `\n// Channel-specific client classes\n`;

    for (const channel of this.channels) {
      const className = `${this.capitalizeFirst(channel.name)}Client`;

      content += `\nexport class ${className} {\n`;
      content += `  constructor(\n`;
      content += `    private client: AsyncAPIWebSocketClient,\n`;
      content += `    private eventBus: AsyncAPIEventBus\n`;
      content += `  ) {}\n\n`;

      // Generate subscribe methods
      if (channel.subscribe.length > 0) {
        for (const message of channel.subscribe) {
          content += `  onReceive${this.capitalizeFirst(message.name)}(\n`;
          content += `    handler: (message: ${message.name}Message) => void | Promise<void>\n`;
          content += `  ): () => void {\n`;
          content += `    return this.eventBus.subscribe('${message.name}', handler);\n`;
          content += `  }\n\n`;
        }
      }

      // Generate publish methods
      if (channel.publish.length > 0) {
        for (const message of channel.publish) {
          content += `  send${this.capitalizeFirst(message.name)}(\n`;
          content += `    payload: ${message.name}Payload`;
          if (message.headers) {
            content += `,\n    headers?: ${message.name}Headers`;
          }
          content += `\n  ): void {\n`;
          content += `    const message: ${message.name}Message = {\n`;
          content += `      payload`;
          if (message.headers) {
            content += `,\n      headers`;
          }
          content += `\n    };\n`;
          content += `    this.client.send('${channel.address}', message);\n`;
          content += `  }\n\n`;
        }
      }

      content += `}\n`;
    }

    return content;
  }

  private capitalizeFirst(str: string): string {
    return str.charAt(0).toUpperCase() + str.slice(1);
  }

  private async generateHandlers(): Promise<void> {
    const outputPath = path.join(this.options.output || 'generated', 'handlers.ts');

    let content = `// Generated AsyncAPI TypeScript handlers\n`;
    content += `// Do not edit this file directly\n`;
    content += `// Generated from: ${path.basename(this.specPath)}\n\n`;

    if (this.options.namespace) {
      content += `import { ${this.options.namespace} } from './types';\n\n`;
      content += `type EventMap = ${this.options.namespace}.EventMap;\n`;
    } else {
      content += `import { EventMap } from './types';\n`;
    }
    content += `\n`;

    // Generate handler interfaces
    content += `// Handler interfaces\n`;
    for (const [name, message] of this.messages) {
      content += `export interface ${message.name}Handler {\n`;
      content += `  handle(message: ${message.name}Message): Promise<void> | void;\n`;
      content += `}\n\n`;
    }

    // Generate abstract base handler
    content += this.generateBaseHandler();

    // Generate handler registry
    content += this.generateHandlerRegistry();

    const formatted = await this.formatCode(content);
    await fs.writeFile(outputPath, formatted);
    console.log(`üìù Generated handlers: ${outputPath}`);
  }

  private generateBaseHandler(): string {
    return `
export abstract class BaseMessageHandler<T extends keyof EventMap> {
  abstract readonly messageType: T;

  abstract handle(message: EventMap[T]): Promise<void> | void;

  protected async validateMessage(message: EventMap[T]): Promise<boolean> {
    // Override in subclasses to add validation logic
    return true;
  }

  protected logError(error: Error, message: EventMap[T]): void {
    console.error(\`Error handling \${String(this.messageType)} message:\`, error);
    console.error('Message:', message);
  }

  async safeHandle(message: EventMap[T]): Promise<void> {
    try {
      const isValid = await this.validateMessage(message);
      if (!isValid) {
        throw new Error(\`Invalid message format for \${String(this.messageType)}\`);
      }

      await this.handle(message);
    } catch (error) {
      this.logError(error as Error, message);
      throw error;
    }
  }
}
`;
  }

  private generateHandlerRegistry(): string {
    return `
export class MessageHandlerRegistry {
  private handlers: Map<keyof EventMap, BaseMessageHandler<any>[]> = new Map();

  register<T extends keyof EventMap>(
    messageType: T,
    handler: BaseMessageHandler<T>
  ): void {
    if (!this.handlers.has(messageType)) {
      this.handlers.set(messageType, []);
    }
    this.handlers.get(messageType)!.push(handler);
  }

  unregister<T extends keyof EventMap>(
    messageType: T,
    handler: BaseMessageHandler<T>
  ): void {
    const handlers = this.handlers.get(messageType);
    if (handlers) {
      const index = handlers.indexOf(handler);
      if (index > -1) {
        handlers.splice(index, 1);
      }
    }
  }

  async handle<T extends keyof EventMap>(
    messageType: T,
    message: EventMap[T]
  ): Promise<void> {
    const handlers = this.handlers.get(messageType) || [];

    const results = await Promise.allSettled(
      handlers.map(handler => handler.safeHandle(message))
    );

    const failures = results.filter(result => result.status === 'rejected');
    if (failures.length > 0) {
      console.error(\`\${failures.length} handler(s) failed for \${String(messageType)}\`);
      failures.forEach((failure, index) => {
        console.error(\`Handler \${index + 1} error:\`, (failure as PromiseRejectedResult).reason);
      });
    }
  }

  getHandlerCount<T extends keyof EventMap>(messageType: T): number {
    return this.handlers.get(messageType)?.length || 0;
  }

  clear(): void {
    this.handlers.clear();
  }

  getRegisteredMessageTypes(): (keyof EventMap)[] {
    return Array.from(this.handlers.keys());
  }
}
`;
  }

  private async generateValidation(): Promise<void> {
    const outputPath = path.join(this.options.output || 'generated', 'validation.ts');

    let content = `// Generated AsyncAPI TypeScript validation schemas\n`;
    content += `// Do not edit this file directly\n`;
    content += `// Generated from: ${path.basename(this.specPath)}\n\n`;

    content += `import { z } from 'zod';\n`;
    if (this.options.namespace) {
      content += `import { ${this.options.namespace} } from './types';\n\n`;
    } else {
      content += `import * as Types from './types';\n\n`;
    }

    // Generate Zod schemas for each message
    content += `// Zod validation schemas\n`;
    for (const [name, message] of this.messages) {
      content += this.generateZodSchema(message);
    }

    // Generate validation functions
    content += this.generateValidationFunctions();

    const formatted = await this.formatCode(content);
    await fs.writeFile(outputPath, formatted);
    console.log(`üìù Generated validation: ${outputPath}`);
  }

  private generateZodSchema(message: MessageInfo): string {
    let content = `\n// ${message.name} validation schema\n`;

    // Generate payload schema
    content += `export const ${message.name}PayloadSchema = `;
    content += this.generateZodSchemaFromJsonSchema(message.payload);
    content += `;\n\n`;

    // Generate headers schema if present
    if (message.headers) {
      content += `export const ${message.name}HeadersSchema = `;
      content += this.generateZodSchemaFromJsonSchema(message.headers);
      content += `;\n\n`;
    }

    // Generate message schema
    content += `export const ${message.name}MessageSchema = z.object({\n`;
    content += `  payload: ${message.name}PayloadSchema,\n`;
    if (message.headers) {
      content += `  headers: ${message.name}HeadersSchema.optional(),\n`;
    }
    content += `  timestamp: z.string().optional(),\n`;
    content += `  messageId: z.string().optional(),\n`;
    content += `});\n\n`;

    return content;
  }

  private generateZodSchemaFromJsonSchema(schema: any): string {
    if (!schema) return 'z.any()';

    switch (schema.type) {
      case 'string':
        if (schema.enum) {
          const enumValues = schema.enum.map((v: string) => `'${v}'`).join(', ');
          return `z.enum([${enumValues}])`;
        }
        let stringSchema = 'z.string()';
        if (schema.minLength) stringSchema += `.min(${schema.minLength})`;
        if (schema.maxLength) stringSchema += `.max(${schema.maxLength})`;
        if (schema.pattern) stringSchema += `.regex(/${schema.pattern}/)`;
        return stringSchema;

      case 'number':
      case 'integer':
        let numberSchema = schema.type === 'integer' ? 'z.number().int()' : 'z.number()';
        if (schema.minimum !== undefined) numberSchema += `.min(${schema.minimum})`;
        if (schema.maximum !== undefined) numberSchema += `.max(${schema.maximum})`;
        return numberSchema;

      case 'boolean':
        return 'z.boolean()';

      case 'array':
        const itemSchema = this.generateZodSchemaFromJsonSchema(schema.items);
        let arraySchema = `z.array(${itemSchema})`;
        if (schema.minItems) arraySchema += `.min(${schema.minItems})`;
        if (schema.maxItems) arraySchema += `.max(${schema.maxItems})`;
        return arraySchema;

      case 'object':
        if (schema.properties) {
          let objectSchema = 'z.object({\n';
          for (const [propName, propSchema] of Object.entries(schema.properties)) {
            const prop = propSchema as any;
            const zodType = this.generateZodSchemaFromJsonSchema(prop);
            const optional = !schema.required?.includes(propName) ? '.optional()' : '';
            objectSchema += `    ${propName}: ${zodType}${optional},\n`;
          }
          objectSchema += '  })';
          return objectSchema;
        }
        return 'z.record(z.any())';

      default:
        return 'z.any()';
    }
  }

  private generateValidationFunctions(): string {
    return `
// Validation utility functions
export class MessageValidator {
  static validate<T>(schema: z.ZodSchema<T>, data: unknown): T {
    return schema.parse(data);
  }

  static safeValidate<T>(schema: z.ZodSchema<T>, data: unknown): {
    success: true;
    data: T;
  } | {
    success: false;
    error: z.ZodError;
  } {
    const result = schema.safeParse(data);
    return result.success
      ? { success: true, data: result.data }
      : { success: false, error: result.error };
  }

  static getValidationErrors(error: z.ZodError): string[] {
    return error.errors.map(err =>
      \`\${err.path.join('.')}: \${err.message}\`
    );
  }
}

// Message-specific validation functions
${Array.from(this.messages.values()).map(message => `
export function validate${message.name}(data: unknown) {
  return MessageValidator.validate(${message.name}MessageSchema, data);
}

export function safeValidate${message.name}(data: unknown) {
  return MessageValidator.safeValidate(${message.name}MessageSchema, data);
}`).join('')}
`;
  }

  private async formatCode(code: string): Promise<string> {
    try {
      return await format(code, {
        parser: 'typescript',
        semi: true,
        singleQuote: true,
        trailingComma: 'es5',
        tabWidth: 2,
        printWidth: 100,
      });
    } catch (error) {
      console.warn('‚ö†Ô∏è  Failed to format code with Prettier, returning unformatted');
      return code;
    }
  }
}

// CLI Program
const program = new Command();

program
  .name('gen-asyncapi')
  .description('Generate TypeScript code from AsyncAPI specifications')
  .version('1.0.0');

program
  .argument('<spec>', 'Path to AsyncAPI specification file')
  .option('-o, --output <dir>', 'Output directory', 'generated')
  .option('-n, --namespace <name>', 'TypeScript namespace for generated types')
  .option('--types', 'Generate TypeScript types', true)
  .option('--client', 'Generate WebSocket client', true)
  .option('--handlers', 'Generate message handlers', true)
  .option('--validation', 'Generate validation schemas', true)
  .option('--no-types', 'Skip type generation')
  .option('--no-client', 'Skip client generation')
  .option('--no-handlers', 'Skip handler generation')
  .option('--no-validation', 'Skip validation generation')
  .action(async (specPath: string, options: GeneratorOptions) => {
    try {
      const generator = new AsyncAPITypeScriptGenerator(specPath, options);
      await generator.generate();
    } catch (error) {
      console.error('‚ùå Generation failed:', error);
      process.exit(1);
    }
  });

// Example usage command
program
  .command('example')
  .description('Show example usage')
  .action(() => {
    console.log(`
üìñ AsyncAPI TypeScript Generator Examples:

# Generate all code from AsyncAPI spec
gen-asyncapi events.yaml

# Generate to specific directory with namespace
gen-asyncapi events.yaml -o src/generated -n EventTypes

# Generate only types and validation
gen-asyncapi events.yaml --no-client --no-handlers

# Generate only client code
gen-asyncapi events.yaml --no-types --no-handlers --no-validation

Generated files:
- types.ts          - TypeScript interfaces and types
- client.ts         - WebSocket client and event bus
- handlers.ts       - Message handler interfaces and registry
- validation.ts     - Zod validation schemas

Usage in your code:
\`\`\`typescript
import { AsyncAPIWebSocketClient, AsyncAPIEventBus } from './generated/client';
import { EventMap } from './generated/types';
import { validateUserCreated } from './generated/validation';

const client = new AsyncAPIWebSocketClient({ url: 'ws://localhost:8080' });
const eventBus = new AsyncAPIEventBus();

await client.connect();

// Subscribe to events
eventBus.subscribe('UserCreated', (message) => {
  console.log('User created:', message.payload);
});

// Send events
client.send('user.events', {
  payload: { userId: '123', email: 'user@example.com' },
  timestamp: new Date().toISOString()
});
\`\`\`
    `);
  });

if (require.main === module) {
  program.parse();
}

export { AsyncAPITypeScriptGenerator };